[TOC]

# 算法

## 排序系列

### 简介

#### 时间复杂度

> 简而言之，计算的次数，通常是指循环执行的次数。

#### 空间复杂度

> 占用空间的大小

#### 稳定性

> **假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。**
>
> 下面给出稳定性示例：给定数组[0,1,0,3,12]，要求将0全部移动到数组的后面，同时保持非0元素的相对位置，即最终的结果是[1,3,12,0,0]。能在排序过程中保持相对位置的算法我们就称其为稳定性算法

### 时间复杂度O(n^2)级算法

#### 冒泡排序

> 重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。

##### 1、算法流程

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤1~3，直到排序完成

##### 2、算法实现

```java
/**
 * 冒泡排序
 * 1、先找出最大的元素，放至最后；
 * 2、在找出第二大的元素，放在倒数第二位置；
 * 3、不断的循环
 */
public void BubbleSort(){
    int[] nums = new int[]{3,4,5,1,2,8,6,7};
    //最外层控制循环的次数，i代表和后面[length-i,lenght)的已排序数组的个数
    for (int i = 0; i < nums.length; i++) {
        //内层循环控制比较次数，随着循环次数i的增大，内层比较次数也越来越少
        //j=1防止j-1为负数
        for (int j = 1; j < nums.length-i; j++) {
            //如果前面的数大于后面的数则交换
            if(nums[j-1]>=nums[j]){
                //交换函数
                swap(nums,j-1,j);
            }
        }
    }

    Arrays.stream(nums).forEach(System.out::println);
}
```

#### 选择排序

> 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

##### 1、算法流程

1. 初始状态：无序区为R[1..n]，有序区为空；
2. 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
3. n-1趟结束，数组有序化了。

##### 2、算法实现

```java
/**
 * 选择排序
 * 1、第一个数与后面的数比较，找出最小的数与第一个数交换
 * 2、第二个数与后面的数比较，找出第二小的数与第二个数交换
 * 3、当i=n-1时，结束
 */
@Test
public void SelectionSort(){
    int[] nums = new int[]{3,4,5,1,2,8,6,7};
    //i控制最外层循环次数，
    for (int i = 0; i < nums.length; i++) {
        //里面的循环代表从当前位置的数一次和后面的数进行比较，找出最小的数交换
        //定义最小位置的索引
        int minIndex = i;
        for (int j = i+1; j < nums.length; j++) {
            //如果后面的数小于当前位置的数，则将最小位置索引定位到当前位置
            if(nums[minIndex]>nums[j]){
                minIndex = j;
            }
        }
        //将当前位置的数与最小位置的数进行交换
        swap(nums,i,minIndex);
    }
    Arrays.stream(nums).forEach(System.out::println);
}
```

#### 插入排序

##### 1、算法流程

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个i+1元素，在已经排序的[0,i)元素序列中从后向前扫描；
3. 如果该元素nums[i]（已排序）大于新元素nums[i+1]，将该元素移到该元素的前一个位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。

##### 2、算法实现

```java
/**
  * 插入排序
  * 1、已第一个元素作为起点，与第二个元素比较，如果大于第二个元素，则交换
  * 2、已第二个元素作为起点，与第三个元素比较，如果大于第三个元素，在与第一个元素比较
  * 3、已第三个元素作为起点，与第四个元素比较，如果大于第四个元素，在比较前两个元素
  */
@Test
public void insertSort(){
    int[] nums = new int[]{3,2,5,1,2,8,6,7};
    //外层循环决定在[0,i]区间内进行插入
    for (int i = 0; i < nums.length-1; i++) {
        //取出下一个数，避免在nums[j+1]的时候该值被覆盖
        int nextNum = nums[i+1];
        //内层循环找出在区间[0-i]中插入的位置
        int preIndex = i;
        for (; preIndex >=0; preIndex--) {
            //移动nums[j]到nums[j+1]的位置
            if(nextNum<nums[preIndex]){
                nums[preIndex+1] = nums[preIndex];
            }else{
                //如果当前位置的数小于nextNum，则将当前位置后面的一个属赋值nextNum
                break;
            }
        }
        nums[preIndex+1] = nextNum;
    }
    Arrays.stream(nums).forEach(System.out::println);
}
```

### 时间复杂度O(nlogn)级算法

#### 快速排序

> 通过分治的思想来将算法平均复杂度降下来，定义一个基准值（通常默认数组的第一个数为pivot），每次遍历的结果会得到两部分数组，数组左边的都小于pivot，数组右边的都大于pivot。

##### 1、算法流程

1. 定义基准数pivot，通常取数组的第一个数为pivot
2. 遍从pivot索引的下一个位置开始遍历数组
3. 将所有小于pivot的数移动到pivot的右边，以数组[3,4,8,5,1,7,2]为例，定义3为pivot，然后将1和2分别移动到临近3的位置，即移动后的数组是[3,1,2,5,4,7,8]，也就是先4和1交换，在执行8和2交换；并且记录最后一次交换后的位置，在此数组中即2的位置
4. 将2的位置与pivot的位置交换，确保pivot左边的数小于等于pivot，右边的数大于pivot
5. 递归操作左区间[left,pivotIndex-1]和右区间[pivotIndex+1,length-1]

##### 2、算法实现

- 从前往后

  ```java
  public void fastSort(int[] nums,int left,int right){
      if(nums.length<1||left>right){
          return;
      }
      int pivotIndex = partition(nums,left,right);
      if(pivotIndex>left){
          fastSort(nums,left,pivotIndex-1);
      }
      if(pivotIndex<right){
          fastSort(nums,pivotIndex+1,right);
      }
  }
  
  public int partition(int[] nums,int left,int right){
      int l = left;
      int pivot = nums[left];
      //该循环以left索引位置为基准值，将所有小于pivot的值放到left索引后面，并且记录最后一次小于基准值的索引位置
      for (int i = l+1; i <= right; i++) {
          //如果基准值大于后边的数，则交换l++与i的值
          if(pivot>nums[i]){
              swap(nums,++l,i);
          }
      }
      //将基准值与最后一次小于基准值的交换，确保基准值左边的都小于等于基准值，右边的大于基准值
      swap(nums,left,l);
      return l;
  }
  ```

- 从后往前遍历

  ```java
  public void quickSort2(int[] arr,int low,int high){
      int start = low;
      int end = high;
      int key = arr[start];
      while (start != end) {
          //从右向左遍历，当遍历的数小于key时，跳出循环
          while (start<end&&key<=arr[end]){
              end--;
          }
          //从左遍历，当遍历的结果大于key时，跳出循环
          while(start<end&&key>=arr[start]){
              start++;
          }
          //交换start和end，最终的结果确保start位置的数全都小于等key
          if(start!=end){
              swap(arr,start,end);
          }
      }
      //交换start和low，使得key前面的数全都小于key，后面的数全都大于key
      swap(arr,start,low);
      if (start > low) {
          quickSort2(arr, low, start - 1);
      }
      if (end < high) {
          quickSort2(arr, end + 1, high);
      }
  
  }
  ```

#### 堆排序

##### 1、堆介绍

**符合以下两个条件之一的完全二叉树：**

- 根节点的值 ≥ 子节点的值，这样的堆被称之为最大堆，或大顶堆；
- 根节点的值 ≤ 子节点的值，这样的堆被称之为最小堆，或小顶堆。

**堆节点的性质：**

- 对于完全二叉树中的第 i 个数，它的左子节点下标：left = 2i + 1
- 对于完全二叉树中的第 i 个数，它的右子节点下标：right = left + 1
- 对于有 n 个元素的完全二叉树(n≥2)(n≥2)，它的最后一个非叶子结点的下标：n/2 - 1

**堆排序过程如下：**

- 用数列构建出一个大顶堆，取出堆顶的数字；
- 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；
- 循环往复，完成整个排序。

##### 2、算法流程

![img](https://assets.leetcode-cn.com/solution-static/912_fig2.gif)

> 以大顶堆为例：初始化数组[4,6,8,5,9]

**构建堆**

1. 第一次角逐：5，6，9三个数找出最大的数作为根节点，数组变成[4,9,8,5,6]

2. 第二次角逐：4，8，9三个住找出最大的数作为根节点，数组编程[9,4,8,5,6]

   值得注意的是，第二次找出最大的数9之后，下面的子节点又需要重新排序，因为此时数组变成[9,4,8,5,6]，4作为5和6的父节点显然不满足根节点大于子节点，所以需要向下继续重新交换

3. 重复以上步骤，直到整个数组完成最大堆的规则则结束

**调整堆**

- 在最大堆（最小堆）基础上调整剩余的数字构建出新的大顶堆，再次取出堆顶的数字；

  以调整完毕的数组[4,6,8,5,9]为例，构建的最大堆结果是[9,6,8,5,4]，此时将4和9交换，然后重新构建[4,6,8,5,9]大顶堆(9不参与构建)，直到调整完毕

- 循环往复，完成整个排序。

##### 3、算法实现

```java
public static void heapSort(int[] arr) {
    // 构建初始大顶堆
    buildMaxHeap(arr);
    for (int i = arr.length - 1; i > 0; i--) {
        // 将最大值交换到数组最后
        swap(arr, 0, i);
        // 调整剩余数组，使其满足大顶堆
        maxHeapify(arr, 0, i);
    }
}
// 构建初始大顶堆
private static void buildMaxHeap(int[] arr) {
    // 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        maxHeapify(arr, i, arr.length);
    }
}
// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小
private static void maxHeapify(int[] arr, int i, int heapSize) {
    // 左子结点下标
    int l = 2 * i + 1;
    // 右子结点下标
    int r = l + 1;
    // 记录根结点、左子树结点、右子树结点三者中的最大值下标
    int largest = i;
    // 与左子树结点比较
    if (l < heapSize && arr[l] > arr[largest]) {
        largest = l;
    }
    // 与右子树结点比较
    if (r < heapSize && arr[r] > arr[largest]) {
        largest = r;
    }
    if (largest != i) {
        // 将最大值交换为根结点
        swap(arr, i, largest);
        // 再次调整交换数字后的大顶堆
        maxHeapify(arr, largest, heapSize);
    }
}
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

#### 归并排序

> 将 1 个数字组成的有序数组合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组...直到整个数组排序完成，这就是归并排序（Merge Sort）的思想。
>

![归并排序.gif](https://pic.leetcode-cn.com/1611902389-UQhJfE-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif)

##### 1、算法流程

1. 将一个数组拆分成2个数组，再将2个数组拆分...如下循环往复直到数组中所有元素个数为1时不进行拆分
2. 将每个最小粒度（元素个数为1）的数组进行排序并合并，两两合并，直到所有的数组都和并完成成为一个数组，此时排序完成

##### 2、算法实现

```java
public static void mergeSort(int[] arr) {
    if (arr.length == 0) return;
    int[] result = new int[arr.length];
    mergeSort(arr, 0, arr.length - 1, result);
}

// 对 arr 的 [start, end] 区间归并排序
private static void mergeSort(int[] arr, int start, int end, int[] result) {
    // 只剩下一个数字，停止拆分
    if (start == end) return;
    int middle = (start + end) / 2;
    // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间
    mergeSort(arr, start, middle, result);
    // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间
    mergeSort(arr, middle + 1, end, result);
    // 合并左右区域到 result 的 [start, end] 区间
    merge(arr, start, end, result);
}

// 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并
private static void merge(int[] arr, int start,  int end, int[] result) {
    int middle = (start + end) / 2;
    // 数组 1 的首尾位置
    int start1 = start;
    int end1 = middle;
    // 数组 2 的首尾位置
    int start2 = middle + 1;
    int end2 = end;
    // 用来遍历数组的指针
    int index1 = start1;
    int index2 = start2;
    // 结果数组的指针
    int resultIndex = start1;
    while (index1 <= end1 && index2 <= end2) {
        if (arr[index1] <= arr[index2]) {
            result[resultIndex++] = arr[index1++];
        } else {
            result[resultIndex++] = arr[index2++];
        }
    }
    // 将剩余数字补到结果数组之后
    while (index1 <= end1) {
        result[resultIndex++] = arr[index1++];
    }
    while (index2 <= end2) {
        result[resultIndex++] = arr[index2++];
    }
    // 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较
    for (int i = start; i <= end; i++) {
        arr[i] = result[i];
    }
}
```

### 计数排序

> 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，**计数排序要求输入的数据必须是有确定范围的整数，即数组中的值有取值范围。**
>
> 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。

#### 1、算法流程

1. 对于数组A，确定数组中最大值范围，定义数组B，B的大小取A数组中的最大值+1；
2. 遍历数组A，将A中的值作为数组B的索引，A中相同值的个数作为数组B的值
3. 遍历数组B，将数组B中的数据依次赋值给数组A

#### 2、算法实现

```java
public void countSort(){
    //从小到大排序
    int[] nums = new int[]{3,4,8,5,2,1,7,2};


    int[] bucket = new int[8+1];
    Arrays.fill(bucket,0);
    //将nums中的值作为bucket中的key，nums中相同数字的个数作为bucket的value
    for (int num : nums) {
        bucket[num]++;
    }

    //记录遍历到nums数组的索引位置
    int j = 0;
    //遍历数组bucket，一次给数组nums赋值；因为遍历顺序是有序的，即先给nums赋值的肯定为较小的数
    for (int i = 0; i < bucket.length; i++) {
        //当bucket[i]<=0时，即证明i位置没有对应的数值了，此时跳出for循环
        while (j<nums.length&&bucket[i]>0){
            nums[j++]=i;
            bucket[i]--;
        }
    }
    Arrays.stream(nums).forEach(System.out::println);
}
```

### 题目实战

| [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/) |
| ------------------------------------------------------------ |
| [移动零](https://leetcode-cn.com/problems/move-zeroes/)      |
| [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) |
| [数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/) |
| [合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/) |

### 参考

https://zhuanlan.zhihu.com/p/60152722

## 二分查找

## 快慢指针



## 

## 动态规划

### 股票买卖

​	**股票系列问题求最大利润，对于在i（大于1）天都可能有三种情况（买入、卖出、保持不动），还可能存在限定交易次数k。**

![股票状态变化](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201128234127.png)

​																												**流程图**

![股票树状图](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201129104825.jpg)

​																															**树状图**

**如上图，股票在第i天手中要么持有股票已经买入（包括当天买入），要么不持有股票（包括当天抛售掉）。**

**对于第一天买入的结果是-price[0],不存在卖出，所以初始化为0；**

**对于第二天要么持有股票，要么不持有股票：**

- **持有股票**

  - **第一天买入，第二天不动；利润依然是第一天的买入的情况-price[0]**
  - **第一天不动，第二天买入；利润是-price[1]**

  > **对于以上这两种情况该如何去选择？**
  >
  > ​		记录当天买入的最大收益，因为买入都是负的，所以最大收益就是找一个价格最低的，即前一天买入的最大收益vs第二天的股价，第一天花了7美元买入的，第二天股票跌到1美元，当然是买第二天的。
  >
  > **第i天买入的最大收益公式为：**
  >
  > ​       **第i天持有股票收益=max(buy[i-1],-price[i])**

- **不持有股票**

  - **第一天买入，第二天卖出；利润是-price[0]+price[1]**
  - **第一天不买入，第二天也不买；利润还是第一天的不持有股票**

  > **对于以上不持有股票该如何选择？**
  >
  > ​       以上图中第二天情况为例：第一天买入的值-7，加上第二天股票价格，也就是第一天我花7美元买入(买入对应收益就是-7)，第二天1美元卖出，所以第二天的卖出收益是-6美元。这当时是亏本了，于是继续不动。
  >
  > **第i天卖出的最大收益公式为：**
  >
  > ​       **第i天未持有股票收益=max(sell[i-1],buy[i-1]+price[i])**

**以此内推，第i天是根据i-1天的值来判断是买还是卖。**

#### 买股票最佳时机-1

- 题目描述

![image-20201128215931834](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201128215938.png)

- 解法一（暴力穷举）

  > 我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。
  >
  > ```java
  > public int maxProfit(int[] prices) {
  >     //先确定最大值
  >     int length = prices.length;
  >     int res = 0;
  >     for (int i = 0; i < length; i++) {
  >         for (int j = i+1; j < length; j++) {
  >             res = Math.max(res,prices[j]-prices[i]);
  >         }
  >     }
  >     return res;
  > }
  > ```
  >
  > 

- 解法二（递归）

  ```java
  //根据树状图推导出出递归雏形
  public int maxProfit(int[] prices){
      int length = prices.length;
      if(length<=1){
          return 0;
      }
      return dfs(prices,0,0,0);
  }
  
  /**
   * @param prices 股票区间
   * @param index 天数
   * @param status 状态 0-买入；1-卖出
   * @param k 交易次数
   * @return
   */
  private int dfs(int[] prices, int index, int status, int k) {
      //当数组执行到头，或者交易了一次结束递归
      if(index==prices.length||k==1){
          return 0;
      }
      //keep不动的值；sell卖出的值；buy买入的值
      int keep=0,sell=0,buy=0;
      keep = dfs(prices,index+1,status,k);
      //对于股票来说要么不动和卖出，要么不动和买入；不可能同时存在不动、买入和卖出三种递归
      //买入
      if(status==0){
          //买入的时候不算一次交易，只有当卖出的时候算作一次交易
          buy = dfs(prices,index+1,1,k)-prices[index];
      }else{
          //卖出的时候交易次数加1
          sell = dfs(prices,index+1,0,k+1)+prices[index];
      }
      return Math.max(Math.max(keep,sell),buy);
  }
  ```

- 解法三（动态规划）

  - 方式一

    ```java
    public int maxProfit3(int[] prices){
        int length = prices.length;
        if(length<=1){
            return 0;
        }
        int[] sells = new int[length];
        int[] buys = new int[length];
        sells[0]=0;
        buys[0]=-prices[0];
        for (int i = 1; i < length; i++) {
            //第i天买入收益 = max(第i-1天买入收益，-当天股价)
            buys[i] = Math.max(-prices[i],buys[i-1]);
            //第i天卖出收益 = max(第i-1天卖出收益，第i-1天买入收益+当天股价)
            sells[i] = Math.max(buys[i-1]+prices[i],sells[i-1]);
        }
        //因为最后一天总是sells[length-1]>buys[length-1]
        return sells[length-1];
    }
    ```

  - 方式二（二维数组）

    ```java
    public int maxProfit(int[] prices){
        int length = prices.length;
        if(length<=1){
            return 0;
        }
        //二维数组的后一个代表持有股票状态
        int[][] dp = new int[length][2];
        //不持有，初始化为0
        dp[0][0] = 0;
        //持有股票，则需要购买
        dp[0][1] = -prices[0];
        for (int i = 1; i < length; i++) {
            //不持有股票
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            //持有股票
            dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
        }
        return dp[length-1][0];
    }
    ```

  - 方式三（二维数组优化后的版本）

    ```java
    //因为不持有股票和持有股票只和前一天有关，所以可以通过不断更新dp[0]和dp[1]的值来刷新当天最大值。
    public int maxProfit5(int[] prices){
        int length = prices.length;
        if(length<=1){
            return 0;
        }
        int[] dp = new int[2];
        dp[1] = -prices[0];
        for (int i = 1; i < length; i++) {
            //不持有股票
            dp[0] = Math.max(dp[0],dp[1]+prices[i]);
            //持有股票
            dp[1] = Math.max(dp[1],-prices[i]);
        }
        return dp[0];
    }
    ```

  - 方式四（贪心算法）

    ![股票买卖1-区间图](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201129114608.png)

    > ​		有以下数组[7, 1, 5, 3, 6, 4]和 [2,5,1,3]；我们需要找出在某个区间段的最大差值。第一个数组区间段是[1-6]，第二个数组区间段是[2-5]。所以我们需要先确定最小值 ，然后不断更新最小值，最大值要和之前的最大值进行比较才判断是否要更新。**在第二个数组中，最小值是1，但是差值最大的区间是[2,5]，所以最小值更新时，最大值不一定更新**。
    >
    > ```java
    > public int maxProfit(int[] prices){
    >     int length = prices.length;
    >     if(length<=1){
    >         return 0;
    >     }
    >     int min = Integer.MAX_VALUE;
    >     int currentProfit = 0;
    >     for (int i = 0; i < length; i++) {
    >         min = Math.min(min,prices[i]);
    >         currentProfit = Math.max(prices[i]-min,currentProfit);
    >     }
    >     return currentProfit;
    > }
    > ```




### 按摩师

- 题目描述

  ![image-20201225214144204](https://image-1301573777.cos.ap-chengdu.myqcloud.com/image-20201225214144204.png)

- 题解

  ```java
  if(nums.length==0){
      return 0;
  }
  if(nums.length==1){
      return nums[0];
  }
  //定义二维数组，
  int[] arrays = new int[2];
  arrays[0] = 0;
  arrays[1] = nums[0];
  for (int i = 1; i < nums.length; i++) {
      arrays[0] = Math.max(arrays[0],arrays[1]);
      arrays[1] = arrays[0]+nums[i];
  }
  return Math.max(arrays[1],arrays[0]);
  ```

### 礼物最大价值

- 题目描述

  ![image-20210503105620578](https://image-1301573777.cos.ap-chengdu.myqcloud.com/image-20210503105620578.png)

- 分析

  该类型题有别于买卖股票类型的题，我们需要计算出每个方格对应的最大值。然后对于在[i,j]坐标位置的方格有以下计算公式：
  $$
  f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j)
  $$
  **另外当i=0,j!=0时，有**
  $$
  f(i,j)=f(i-1,0)+grid(i,0)
  $$
  **当i!=0,j=0时，有**
  $$
  f(i,j)=f(0,j-1)+grid(0,j)
  $$
  **当i=0,j=0时，有**
  $$
  f(i,j) = grid(0,0)
  $$

- 题解

  ```java
  /**
   * 对于二维数组 n是行的长度，m是列的高度
   * 礼物的最大价值
   * @param grid
   * @return
   */
  public int maxValue(int[][] grid) {
  
      if(grid==null||grid.length==0){
          return 0;
      }
      int m = grid.length;
      int n = grid[0].length;
      int[][] dp = new int[m][n];
      dp[0][0] = grid[0][0];
      for (int i = 1; i < n; i++) {
          dp[0][i] = dp[0][i-1]+grid[0][i];
      }
      for (int i = 1; i < m; i++) {
          dp[i][0] = dp[i-1][0]+grid[i][0];
      }
  
      for (int i = 1; i < m; i++) {
          for (int j = 1; j < n; j++) {
  
              dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+grid[i][j];
          }
      }
  
      return dp[m-1][n-1];
  }
  ```

  

## 回溯算法

- 题目描述

![image-20201225215745413](https://image-1301573777.cos.ap-chengdu.myqcloud.com/image-20201225215745413.png)

- 题解

  ```java
  class Solution119 {
      //最终输出结果的list
      List<String> res = new ArrayList<>();
      String[] letter_map = {" ","*","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
      public List<String> letterCombinations(String digits) {
          //注意边界条件
          if(digits==null || digits.length()==0) {
              return new ArrayList<>();
          }
          iterStr(digits, new StringBuilder(), 0);
          return res;
      }
  
      /**
       *
       * @param str 23
       * @param letter 存储的结果集 比如 ad ae af
       * @param index
       */
      private void iterStr(String str, StringBuilder letter, int index) {
          if(index==str.length()){
              res.add(letter.toString());
              return;
          }
          char c = str.charAt(index);
          int pos = c - '0';
          String mapString = letter_map[pos];
          for (int i = 0; i < mapString.length(); i++) {
              //添加第一个元素
              letter.append(mapString.charAt(i));
              iterStr(str,letter,index+1);
              //在一个循环中删除添加的第一个元素，保证StringBuilder没有多余其他值
              letter.deleteCharAt(letter.length()-1);
          }
      }
  
  }
  ```

  

