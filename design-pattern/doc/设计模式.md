# 设计模式

## 设计模式的原则

### 1、单一职责（SRP）

#### 定义

​	应该仅有一个原因引起类的变更。

#### 优点

- 类的复杂性降低，实现什么职责都有明确清晰的定义
- 可读性提高
- 可维护性提高
- 变更引起的风险降低；对系统的扩展性和可维护性都有非常大的帮助

### 2、里氏替换原则（LSP）

- 如果对于每一个类型为S的对象o1都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1替换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。
- 所有引用（父类）基类的地方必须能透明的使用其子类的对象。（反之不成立）

> 对于重载，则要求方法的输入参类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说子类的方法不会被调用。

### 3、依赖倒置原则（DIP）

> 依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。

**原则**

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象

  > 每一个逻辑都是由原子组成，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块

- 抽象不应该依赖细节

  > 在java中抽象就是指接口或抽象类，两者都不能直接被实例化

- 细节应该依赖抽象

  > 细节就是实现类，实现接口或继承抽象类而产生的类就是细节

### 4、接口隔离原则

> 建立单一接口，不要建立臃肿庞大的接口。

**原则**

- 接口尽量要小（同时满足单一原则，不能过度拆分)

- 接口要高内聚

  要求接口尽量少公布`public`方法，接口是对外的承诺，承诺越少对系统开发越有利，变更风险越低

- 定制服务

- 接口设计有限度

### 5、迪米特法则（LoD）

> 迪米特法则也成为最少知道原则，即一个对象应该对其他对象有最少的了解；尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-package、protected等访问权限。

### 6、开闭原则

> 软件实体应该对扩展开放，对修改关闭，其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。

## 23种设计模式

### 1、单例模式

> 每个类只能产生一种实例对象

**饿汉模式**

```java
public class Singleton{
    private static final singleton = new Singleton();
    //私有构造
    private Singleton(){
        
    }
    public static Singleton getSingleton(){
        return singleton;
    }
}
```

> 弊端：对于反射和序列化创建的对象无法控制，而且初始化就创建，浪费一些不必要的资源。

**懒汉模式**

**模式一**

```java
//弊端：线程不安全
public class LazySingleton {
    private static LazySingleton singleton = null;

    private LazySingleton(){

    }
    public static LazySingleton getInstance(){
        if(singleton==null){
            return new LazySingleton();
        }
        return singleton;
    }
}
```

**模式二**

```java
//类锁范围过大，影响性能
public class LazySingleton2 {
    private static LazySingleton2 singleton;

    private LazySingleton2(){

    }
    public static LazySingleton2 getInstance(){
        synchronized (LazySingleton2.class){
            if(singleton==null){
                singleton = new LazySingleton2();
            }
            return singleton;
        }
    }
}
```

**模式三**

```java
//双重检查
/*
 *  弊端：
 *      由于线程可见性，在线程A初始化完毕后，线程B读到的可能不为null，直接返回instance,
 *  此时instance还没有指向内存地址
 *  产生原因：可能顺序变成1>3>2,即singleton未初始化
 *  jvm创建对象（线程可见性、创建对象没有实现原子性操作）
 *      1.分配内存给这个对象
 *      2.初始化对象（第三步还没有执行，就执行了线程B的逻辑）
 *      3.设置singleton指向刚分配的内存地址
 *  解决办法：使用volatile关键字，禁止JVM的指令重排序
 */v
public class LazySingleton3 {
    private volatile static LazySingleton3 singleton;

    private LazySingleton3(){

    }
    public static LazySingleton3 getInstance(){
        if(singleton==null){
            synchronized (LazySingleton3.class){
                if(singleton==null){
                    singleton = new LazySingleton3();
                }
                return singleton;
            }
        }
        return singleton;
    }
}
```

**静态内部类**

```java
/**
*当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getInstance() 方  *法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能*确保 INSTANCE 只被实例化一次。
*/
public class Singleton {

    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }

    private Singleton() {
        
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```

**枚举**

```java
//最完美的一种方法，既防止序列化又保证了线程安全
public enum  EnumSingleton {
    INSTANCE;
    private Object data;
    public  Object getData(){
        return data;
    }
    public void setData(Object data){
        this.data = data;
    }
    public static EnumSingleton getInstance(){
        return INSTANCE;
    }
}
```

> 枚举之前的方法都可以通过反射或者序列化来破坏单例，而枚举则避免了各种实例化的方式

为什么枚举能阻止序列化？

```java
//反编译枚举的class文件
package com.fuzy.example.single;


public final class EnumSingleton extends Enum
{

	public static final EnumSingleton INSTANCE;
	private Object data;
	private static final EnumSingleton $VALUES[];

	public static EnumSingleton[] values()
	{
		return (EnumSingleton[])$VALUES.clone();
	}

	public static EnumSingleton valueOf(String name)
	{
		return (EnumSingleton)Enum.valueOf(com/fuzy/example/single/EnumSingleton, name);
	}

	private EnumSingleton(String s, int i)
	{
		super(s, i);
	}

	public Object getData()
	{
		return data;
	}

	public void setData(Object data)
	{
		this.data = data;
	}

	public static EnumSingleton getInstance()
	{
		return INSTANCE;
	}

	static 
	{
		INSTANCE = new EnumSingleton("INSTANCE", 0);
		$VALUES = (new EnumSingleton[] {
			INSTANCE
		});
	}
}
```

参考地址：[深度理解枚举](https://my.oschina.net/90888/blog/862609)

### 2、工厂模式

#### 简单工厂

> 简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。所有产生产品的实例操作都在一个工厂类中。

![简单工厂](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201107094929.png)

​																				**简单工厂类图**

#### 工厂模式

> 定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类

![工厂模式](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201107100247.png)

​																					**工厂模式类图**

#### 抽象工厂

在熟悉抽象工厂之前，先认识下产品族

![产品族](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201107105009.png)

​																						**产品-产品等级**

> 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。抽象工厂模式用到了工厂方法模式来创建单一对象，`HumanFactory` 中的方法都是让子类来实现，这些方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

![抽象工厂](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201107105924.png)

​																						**抽象工厂类图**

**注意事项**

​	**以`产品-产品等级`为例，横坐标性别代表着产品等级，纵桌标代表着产品族，如果要扩展产品等级只需要在创建一个工厂类和三个不同肤色的类，就可以实现业务扩展，并且不违背开闭原则；但是如果要扩展产品族，则会去修改好几个对应的类，严重违反了开闭原则。**

[^设计模式之禅]: 该内容参考第9章抽象工厂

其他参考地址：

[抽象工厂1](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.md)

[抽象工厂2](https://www.cnblogs.com/canglg/p/10521437.html)







