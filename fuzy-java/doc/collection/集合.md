# `ArrayList`

## 1.概述

​	`ArrayList`实现了`List`接口，元素存放的数据与放进去的顺序相同，允许放入`null`元素，底层通过数组实现，支持自动扩容。

## 2.类图

![List类图](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201012223634.png)

由类图可知`ArrayList`实现了4个接口，分别是：

- List接口，提供数组的添加、删除、修改、迭代遍历等操作
- [`RandomAccess`](https://github.com/YunaiV/openjdk/blob/master/src/java.base/share/classes/java/util/RandomAccess.java) 接口，表示 `ArrayList` 支持**快速**的随机访问
- `Serializabel`接口，支持序列化功能
- `Cloneable`接口，支持克隆

## 3.属性

```java
//无参构造添加第一个元素时会默认初始化容量
private static final int DEFAULT_CAPACITY = 10;
//空的数组
private static final Object[] EMPTY_ELEMENTDATA = {};
//无参构造默认的数组地址
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
//元素数组，当初始化无参构造数组时，会默认this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA
//当添加第一个元素时，会将数组扩大至DEFAULT_CAPACITY容量
transient Object[] elementData; 
//数组时机大小
private int size;
```

![ArrayList](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201012225742.png)

- `elementData`属性

  ​	元素数组，构造一个空`ArrayList`时，该属性被初始化`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`；图中红色空格代表我们已经添加元素，白色空格代表我们并未使用。

- `size`属性

  ​	数组大小。注意，`size` 代表的是 `ArrayList` 已使用 `elementData` 的元素的数量，对于开发者看到的 `#size()` 也是该大小。并且，当我们添加新的元素时，恰好其就是元素添加到 `elementData` 的位置（下标）。当然，我们知道 `ArrayList` **真正**的大小是 `elementData` 的大小。

## 4.构造方法

### 4.1无参构造

```java
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

### 4.2有参构造-初始化数组大小

```java
private static final Object[] EMPTY_ELEMENTDATA = {};
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}
```

### 4.3有参构造-传入集合

```java
public ArrayList(Collection<? extends E> c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
```

> - 在我们学习`ArrayList`的时候，一直被灌输了一个概念，在未设置初始化容量时，`ArrayList`默认大小为 10 。但是此处，我们可以看到初始化为 `DEFAULTCAPACITY_EMPTY_ELEMENTDATA` 这个空数组。这是为什么呢？`ArrayList` 考虑到节省内存，一些使用场景下仅仅是创建了`ArrayList`对象，实际并未使用。所以，`ArrayList`优化成初始化是个空数组，在首次添加元素时，才真正初始化为容量为 10 的数组。
> - 那么为什么单独声明了 `DEFAULTCAPACITY_EMPTY_ELEMENTDATA` 空数组，而不直接使用 `EMPTY_ELEMENTDATA` 呢？在下文中，我们会看到 `DEFAULTCAPACITY_EMPTY_ELEMENTDATA` 首次扩容为 10 ，而 `EMPTY_ELEMENTDATA` 按照 **1.5 倍**扩容从 0 开始而不是 10 。 两者的起点不同。

## 5.添加元素

### 5.1添加单个元素

```java
/**
 * 添加单个元素
 */
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
private void ensureCapacityInternal(int minCapacity) {
    //当无参构造初始化集合时，第一次添加元素初始化数组容量为10
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}
private void ensureExplicitCapacity(int minCapacity) {
    //记录修改次数
    modCount++;
	//扩容
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

```

### 5.2指定位置添加一个元素

```java
public void add(int index, E element) {
    //校验索引是否非法
    rangeCheckForAdd(index);
	//修改modcount次数，增加容量
    ensureCapacityInternal(size + 1); 
    //从index+1位置复制数组
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}
```



![ArrayList_add](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201014211340.png)

​																				**add添加元素**

## 6.数组容量

### 6.1数组扩容

```java
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
```

![ArrayList_grow](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201014211103.png)

​																		**集合扩容过程**

### 6.2数组缩容

```java
public void trimToSize() {
    modCount++;
    if (size < elementData.length) {
        elementData = (size == 0)
            ? EMPTY_ELEMENTDATA
            : Arrays.copyOf(elementData, size);
    }
}
```

## 7.移除元素

### 7.1移除元素

```java
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index < size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index < size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false
}

private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}
```

### 7.2移除多个元素

```java
public boolean removeAll(Collection<?> c) {
    Objects.requireNonNull(c);
    return batchRemove(c, false);
}
private boolean batchRemove(Collection<?> c, boolean complement) {
    final Object[] elementData = this.elementData;
    int r = 0, w = 0;
    boolean modified = false;
    try {
        for (; r < size; r++)
            if (c.contains(elementData[r]) == complement)
                elementData[w++] = elementData[r];
    } finally {
        // Preserve behavioral compatibility with AbstractCollection,
        // even if c.contains() throws.
        //如果 contains 方法发生异常执行该方法
        if (r != size) {
            //elementData就是数组前r+1个元素不变，后面的元素从第w个元素开始替换到size-r长度结束，其中[w-size-r]元素的值分别对应着[elementData[r+1]-elementData[size-r]]的值
            System.arraycopy(elementData, r,
                             elementData, w,
                             size - r);
            w += size - r;
        }
        if (w != size) {
            // clear to let GC do its work
            for (int i = w; i < size; i++)
                elementData[i] = null;
            modCount += size - w;
            size = w;
            modified = true;
        }
    }
    return modified;
}
```

## 8.查找元素

### 8.1查找单个元素

```java
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i < size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
```

### 8.2获取指定位置的元素

```java
public E get(int index) {
    rangeCheck(index);

    return elementData(index);
}
```

## 9.序列化

### 序列化集合

```java
//transient阻止序列化
transient Object[] elementData; 
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i<size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
```

### 反序列化

```java
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size > 0) {
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i<size; i++) {
            a[i] = s.readObject();
        }
    }
}
```

## 10.创建 Iterator 迭代器

```java
public Iterator<E> iterator() {
    return new Itr();
}
/**
 * 迭代器代码
 */
private class Itr implements Iterator<E> {
    //游标
    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;

    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        //<1> 校验expectedModCount = modCount是否相等
        checkForComodification();
        int i = cursor;
        if (i >= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }

    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void forEachRemaining(Consumer<? super E> consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i >= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size && modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }
    
    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
```

- `checkForComodification`比较`modCount != expectedModCount`值不相等抛出`ConcurrentModificationException`异常
- `#hasNext`方法判断游标有没有达到最后位置
- `#next`方法，每次移动一次，游标`cursor`+1
- `#remove`方法，会重新调用集合的`remove`方法，并且重新初始化`expectedModCount = modCount`，所以永迭代器遍历删除元素不会抛出`ConcurrentModificationException`异常

## 11.仿写`ArrayList`



## 小结

- `ArrayList` 是基于 `[]` 数组实现的 List 实现类，支持在数组容量不够时，一般按照 **1.5** 倍**自动**扩容。同时，它支持**手动**扩容、**手动**缩容。
- `ArrayList` 随机访问时间复杂度是 O(1) ，查找指定元素的**平均**时间复杂度是 O(n) 。
- `ArrayList` 移除指定位置的元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 
- `ArrayList` 移除指定元素的时间复杂度是 O(n) 。
- `ArrayList`添加元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 。

# `LinkedList`

## 1.概述

`LinkedList`同时实现了`List`接口和`Deque`接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(*Queue*)，同时又可以看作一个栈(*Stack*)。

![LinkedList_base](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201021232245.png)

## 2.类图

![LinkedList](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201021232330.png)

## 3.属性

```java
transient int size = 0;
/**
 * first始终不变：
 * 1、集合没有元素：first == null && last == null
 * 2、集合添加了元素：first.prev == null && first.item != null
 */
transient Node<E> first;

/**
 * last始终不变：
 * 1、集合没有元素：first == null && last == null
 * 2、集合添加了元素：(last.next == null && last.item != null)
 */
transient Node<E> last;
```

## 4.无参构造

```java
/**
 * 构造一个空集合
 */
public LinkedList() {
}
```

## 5.添加元素

### 5.1 添加元素

```java
//添加元素到链表末尾
public boolean add(E e) {
    linkLast(e);
    return true;
}
/**
 * first  last
 * first a b last
 *
 */
void linkLast(E e) {
    final Node<E> l = last;
    //创建节点
    final Node<E> newNode = new Node<>(l, e, null);
    //last始终指向尾节点
    last = newNode;
    //首次添加元素
    if (l == null)
        //first始终指向头节点
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

![LinkedList添加元素](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201025225629.png)

### 5.2 指定位置添加元素

```java
public void add(int index, E element) {
    checkPositionIndex(index);
    //如果index=size,直接在末尾添加，等同于add(e)方法
    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}
/**
 * 返回需要修改节点的位置
 */
Node<E> node(int index) {
   	//根据当前添加元素的位置判断是从头开始找还是尾开始找
    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
/**
 * 将前一个节点next->newNode
 * 将后一个节点pre->newNode
 */
void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    final Node<E> pred = succ.prev;
    final Node<E> newNode = new Node<>(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
```

![LinkedList_add](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201025231134.png)

## 6. 获取元素

### 6.1 获取第一个元素

```java
public E getFirst() {
    final Node<E> f = first;
    if (f == null)
        throw new NoSuchElementException();
    return f.item;
}
```

### 6.2 获取最后一个元素

```java
public E getLast() {
    final Node<E> l = last;
    if (l == null)
        throw new NoSuchElementException();
    return l.item;
}
```

## 7 移除元素

```java
public boolean remove(Object o) {
    if (o == null) {
        for (Node<E> x = first; x != null; x = x.next) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for (Node<E> x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}
E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
```

![LinkedList_remove](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201025230220.png)

## 8 仿写`LinkedList`

## 9 小结

- `LinkedList`是链表结构，所以不存在扩容。
- `LinkedList` 基于节点实现的**双向**链表的 List ，每个节点都指向前一个和后一个节点从而形成链表。
- `LinkedList`随机访问**平均**时间复杂度是 O(n) ，查找指定元素的**平均**时间复杂度是 O(n) 。
- `LinkedList`移除指定位置的元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 。
- `LinkedList`添加元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 。

# `HashMap`

## 1.概述

​	`HashMap` 是一种[散列表](https://zh.wikipedia.org/wiki/哈希表)，用于存储 key-value 键值对的数据结构，一般翻译为“哈希表”，提供**平均**时间复杂度为 O(1) 的、基于 key 级别的 get/put 等操作。

### **`hashMap`存储数据的原理**

> `HashMap` 所提供的 O(1) 是**平均**时间复杂度，大多数情况下保证 O(1) ；原因是：**hash函数** ，通过 `hash(key)` 的过程，我们可以将 key 成功的转成一个整数。但是，`hash(key)` 可能会超过数组的容量，所以我们需要 `hash(key) % size` 作为下标，放入数组的对应位置。

![散列表](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201102221739.png)

​																					**散列表**

​	通过哈希函数将key和数组下标进行转换，最后快速找到对应的下标的元素。

![哈希冲突](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201102222118.png)

​																					**哈希冲突**

### **解决哈希冲突**

- 开放寻址法

  > 当一个Key通过哈希函数获得对应的数组下标已被占用时，我们可以“另谋高就”，寻找下一个空档位置。（寻址方 式有很多种，并不一定只是简单地寻找当前元素的后一个元素）

- 链表法

  ![链表法](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201102222527.png)

  > `HashMap`数组的每一个元素不仅是一个Entry对象，还是一个链表的 头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新 来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中 即可。

### 时间复杂度的几种情况

- 1、每个 key 经过 `hash(key) % size` 对应唯一下标，则 get 时间复杂度是 O(1) 。
- 2、k 个 key 经过 `hash(key) % size` 对应唯一下标，那么在 get 这 k 个 key 的时间复杂度是 O(k) 。
- 3、在链表法的极端情况下，所有数据恰好落在一个节点上 ，那么就出现O(N) 的时间复杂度的情况。

### `jdk`不同版本的实现

- 在 `JDK7` 的版本中，`HashMap` 采用“数组 + 链表”的形式实现。
- 在 `JDK8` 开始的版本，`HashMap` 采用“数组 + 链表 + 红黑树”的形式实现，在空间和时间复杂度中做取舍。

![基于jdk8的HashMap实现](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201102224410.jpg)

## 2.类图

![HashMap类图](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201102222814.png)

## 3.属性

```java
//默认的初始化容量
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
//最大容量
static final int MAXIMUM_CAPACITY = 1 << 30;
//当size超过初始容量的0,75倍时，进行扩容；例如初始12，size=16,当16*0.75>=12就扩容
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//底层存储的数组 包含 key,hase,nextNode属性，对应的value
transient Node<K,V>[] table;
//key-value 的键值对数量
transient int size;
//HashMap 的修改次数
transient int modCount;
//阀值，当size超过threshold大小时，2倍扩容
int threshold;
//扩容因子
final float loadFactor;
```

## 4.构造方法

### 4.1 无参构造

```java
/**
 * 初始化容量 DEFAULT_INITIAL_CAPACITY=16
 * 初始化 loadFactor = 0.75f
 * 并且是延迟初始化，在添加key-value键值对时，在#resize()方法中才真正去初始化
 */
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
```

### 4.2 带容量的构造

```java
/**
 * 初始化因子不变
 */
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
/**
 *tableSizeFor的功能（不考虑大于最大容量的情况）是返回大于输入参数且最近的2的整数次幂的数。比如10，则返回16。
 * https://www.jianshu.com/p/cbe3f22793be
 */
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

### 4.3 传递map的构造

```java
public HashMap(Map<? extends K, ? extends V> m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}

final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
    int s = m.size();
    if (s > 0) {
        //table为空，说明未初始化
        if (table == null) { // pre-size
            // 根据 s 的大小 + loadFactor 负载因子，计算需要最小的 tables 大小；+ 1.0F 的目的，是因为下面 (int) 直接取整，避免不够。
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft < (float)MAXIMUM_CAPACITY) ?
                     (int)ft : MAXIMUM_CAPACITY);
            //如果计算出来的 t 大于阀值，则计算新的阀值
            if (t > threshold)
                threshold = tableSizeFor(t);
        }
        //s大于极端的大小  扩容 
        else if (s > threshold)
            resize();
        //遍历m集合，将数据逐个添加到HashMap中
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}
```

## 5.哈希函数

```java
static final int hash(Object key) {
    int h;
    // h = key.hashCode() 计算哈希值
    // ^ (h >>> 16) 高 16 位与自身进行异或计算，保证计算出来的 hash 更加离散
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

- 高效性：从整个计算过程上来说，`^ (h >>> 16)` 只有这一块的逻辑，两个位操作，性能肯定是有保障的。那么，如果想要保证哈希函数的高效性，就需要传入的 `key` 自身的 `Object#hashCode()` 方法的高效即可。
- 离散型：和大多数胖友有一样的疑惑，为什么有 `^ (h >>> 16)` 一段代码呢，总结来说，就是保证“hash 更加离散”。关于这块的解释，直接来看 [《JDK 源码中 HashMap 的 hash 方法原理是什么？》](https://www.zhihu.com/question/20733617/answer/111577937) 的胖君的解答 ，好强！

## 6.添加元素

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    //table未初始化，或者容量为0，进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //如果得到位置的节点Node为空，则直接创建节点
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        //如果找到的p节点就是要找的，则直接使用即可
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        //如果找到的p节点属于红黑树Node节点，则直接添加到树种
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            //否则遍历链表
            for (int binCount = 0; ; ++binCount) {
                //如果遍历到空说明该map种不存在key，则创建新节点，同时将链表的尾节点指向新建的节点
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    //链表的长度达到8时，则转换成红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                //链表中遍历的节点就是要找的节点，则直接使用
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        //如果找到了对应的节点，则修改老节点的value值，返回oldValue
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    // 增加修改次数
    ++modCount;
    // 如果超过阀值，则进行扩容
    if (++size > threshold)
        resize();
    // 添加节点后的回调
    afterNodeInsertion(evict);
    //默认没有对应的节点，则返回null
    return null;
}
```

![HashMap添加执行流程](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201106221709.jpg)

## 7.扩容

> 问题：扩容后如果保证原来的hash值能够找到对应的位置

```java
//初始化或者翻倍数组大小。翻倍后，元素的位置或者在原来的位置上，或者有个2的整数次幂的偏移，根据我们前面举的具体扩容的例子，知道这个偏移就是原来的数组大小。
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    //未初始化设置旧容量为0
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        //2倍扩容
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    //oldThr 大于 0 ，则使用 oldThr 作为新的容量
    else if (oldThr > 0) 
        newCap = oldThr;
    else {               
        //【默认构造方法】oldThr 等于 0 ，则使用 DEFAULT_INITIAL_CAPACITY 作为新的容量，使用 DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY 作为新的容量
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    //如果上述的逻辑，未计算新的阀值，则使用 newCap * loadFactor 作为新的阀值
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    //阈值重置
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    //构建大小为newCap的数组节点
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    //旧数组节点重新赋值
    table = newTab;
    //旧数组初始化过
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            //旧数组每一个数组节点不为空
            if ((e = oldTab[j]) != null) {
                //将旧数组节点置为空
                oldTab[j] = null;
                //如果 e 节点只有一个元素，直接赋值给新的 table 即可
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                //如果 e 节点是红黑树节点，则通过红黑树分裂处理
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                //e元素节点next元素有值，即链表存在多个且小于8个的元素
                else { 
                    // HashMap 是成倍扩容，这样原来位置的链表的节点们，会被分散到新的 table 的两个位置中去
                    // 通过 e.hash & oldCap 计算，根据结果分到高位、和低位的位置中。
                    // 1. 如果结果为 0 时，则放置到低位，不移动位置
                    // 2. 如果结果非 1 时，则放置到高位
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        //链表中下一个元素
                        next = e.next;
                        //满足低位，放到低位中
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        //满足高位
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 设置低位到新的 newTab 的 j 位置上
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // 设置高位到新的 newTab 的 j + oldCap 位置上
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

**高低位索引机制**

**未重新索引（最高位为0）**：假设hash值h二级制为`0010 1100 1111 0001 1110 1110`长度为`16`，14的索引位置依然是14

**扩容前**

h                0010 1100 1111 0001 1110 1110

length-1     0000 0000 0000 0000 0000 1111

h&length    0000 0000 0000 0000 0000 1110 

**2倍扩容后**

h                0010 1100 1111 0001 1110 1110

length-1     0000 0000 0000 0000 0001 1111

h&length    0000 0000 0000 0000 0000 1110 

**重新索引（最高位为1）**：假设hash值h二级制为`0010 1100 1111 0100 0001 0010`，长度为`16`，2的索引变成18的位置

**扩容前**

h                0010 1100 1111 0100 0001 0010

length-1     0000 0000 0000 0000 0000 1111

h&length    0000 0000 0000 0000 0000 0010 

**2倍扩容后**

h                0010 1100 1111 0100 0001 0010

length-1     0000 0000 0000 0000 0001 1111

h&length    0000 0000 0000 0000 0001 0010 

[参考链接](https://www.h3399.cn/201906/703664.html)

