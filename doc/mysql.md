# MySQL

[mysql执行顺序](https://www.cnblogs.com/wyq178/p/11576065.html)

## MySQL基础架构

### 连接器

连接器的主要职责就是:

①负责与客户端的通信,是半双工模式,这就意味着某一固定时刻只能由客户端向服务器请求或者服务器向客户端发送数据,而不能同时进行,其中mysql在与客户端连接TC/IP的

②验证请求用户的账户和密码是否正确,如果账户和密码错误,会报错:Access denied for user 'root'@'localhost' (using password: YES)

③如果用户的账户和密码验证通过,会在mysql自带的权限表中查询当前用户的权限:

mysql中存在4个控制权限的表，`分别为**user表，db表，tables_priv表，columns_priv表**,`mysql权限表的验证过程为：

1:`User表:`存放用户账户信息以及全局级别（所有数据库）权限，决定了来自哪些主机的哪些用户可以访问数据库实例
 **Db表:**存放`数据库级别`的权限，决定了来自哪些主机的哪些用户可以访问此数据库 
 **Tables_priv**表：`存放表级别的权限`，决定了来自哪些主机的哪些用户可以访问数据库的这个表 
 **Columns_priv**表：`存放列级别的权限`，决定了来自哪些主机的哪些用户可以访问数据库表的这个字段 
 **Procs_priv**表：`存放存储过程和函数`级别的权限

2:先从user表中的Host,User,Password这3个字段中判断连接的ip、用户名、密码是否存在，存在则通过验证。

3:通过身份认证后，进行权限分配，按照user，db，tables_priv，columns_priv的顺序进行验证。即先检查全局权限表user，如果user中对应的权限为Y，则此用户对所有数据库的权限都为Y，将不再检查db, tables_priv,columns_priv；如果为N，则到db表中检查此用户对应的具体数据库，并得到db中为Y的权限；如果db中为N，则检查tables_priv中此数据库对应的具体表，取得表中的权限Y，以此类推

4:如果在任何一个过程中权限验证不通过,都会报错

### 缓存

> ​	mysql的缓存主要的作用是为了提升查询的效率，缓存以key和value的哈希表形式存储，key是具体的sql语句，value是结果的集合。如果无法命中缓存,就继续走到分析器的的一步,如果命中缓存就直接返回给客户端 。不过需要注意的是在mysql的8.0版本以后，缓存被官方删除掉了。之所以删除掉,是因为查询缓存的失效非常频繁,如果在一个写多读少的环境中,缓存会频繁的新增和失效。对于某些更新压力大的数据库来说，查询缓存的命中率会非常低

**关闭缓存**

```sql
query_cache_type=DEMAND
```

**使用缓存**

```sql
mysql> select SQL_CACHE * from T where ID=10；
```

### 分析器

> 如果没有命中缓存，就要开始真正执行语句了。它会将输入的Sql做语法分析，判断你输入的SQL语句是否满足MySQL的语法。如下面语句，会报出“You have an error in your SQL syntax”的错误提醒
>
> ```sql
> mysql> elect * from t where ID=1;
> ```

### 优化器

> 优化器的作用就是决定选择使用哪一个方案。示例一中两种查询方案都符合要求，但是效率会不同，MySQL会根据优化器来筛选出最有方案。

**示例一**

```sql
 mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
```

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
-  也可以先从表 t2 里面取出 c=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

**示例二**

### 执行器

**校验权限**

```sql
mysql> select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

**调用接口**

比如我们这个例子中的表 T 中，那么执行器的执行流程是这样的：

- 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果中； 
- 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
- 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 

至此，这个语句就执行完成了。

**执行顺序**

## MySQL日志

### redo log

​	InnoDB引擎特有的日志

### bin log

​	Server层的日志

## MySQL事务

### 事务的特性

- 原子性
- 一致性
- 隔离性
- 持久性

### 事务隔离级别

在多个事务同时执行下，就可能出现脏读（dirty read）、不可重复读（non reapeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级 别”的概念。

- 读未提交（`read uncommitted`）

  > 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。

- 读提交（`read committed`）

  > 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。

- 可重复读（`repeatable read`）

  > 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

- 串行化（`serializable`）

  > 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现 读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

下面已示例来了解这四个隔离级别：

![image-20210319082838757](C:\Users\fuzy\AppData\Roaming\Typora\typora-user-images\image-20210319082838757.png)

我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、 V3 的返回值分别是什么。

- 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果 已经被 A 看到了。因此，V2、V3 也都是 2。

- 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看 到。所以， V3 的值也是 2。 

- 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这 个要求：事务在执行期间看到的数据前后必须是一致的。 

  > 使用场景：假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时 候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。 你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

- 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

​     在实现上，数据库里面会创建一个**视图**，访问的时候以视图的逻辑结果为准。**在“可重复读”隔 离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔 离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提 交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁 的方式来避免并行访问。**

### 事务隔离的实现

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![image-20210319084222289](https://image-1301573777.cos.ap-chengdu.myqcloud.com/image-20210319084222289.png)

对于 read-view A，要得到 1，就必须 将当前值依次执行图中所有的回滚操作得到。同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对 应的事务是不会冲突的。

### 事务的启动方式

MySQL 的事务启动方式有以下几种：

- 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句 是 rollback。 
- set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。

​     有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下 来的查询都在事务中，如果是长连接，就导致了意外的长事务。长事务意味着系统里面会存在很老的事务视图，会占用大量的存储空间。

你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用 于查找持续时间超过 60s 的事务。

```sql
1 select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

