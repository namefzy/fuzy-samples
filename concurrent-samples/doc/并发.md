# 并发编程

## 1、并发编程基础

### 1、1 线程与进程

**进程**

> ​	我们都知道计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是**操作系统进行资源分配和调度**的一个独立单位，是应用程序运行的载体。

**线程**

> ​	线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。**一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。真正占用CPU运行的是线程，所以也说线程是CPU分配的基本单位。**

**线程与进程的区别**

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；

4. 调度和切换：线程上下文切换比进程上下文切换要快得多

![进程与线程](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201118232218.png)

​																						**进程与线程**

### 1、2 并发

> ​	**大部分操作系统的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态，等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。**
>
> ​	**那么在时间片被其他线程占用后，如何知道之前的线程执行到哪里了？程序计数器（pc计数器）就是为了记录该线程让出CPU时的执行地址的。待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行。另外需要注意的是：如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是java代码时pc计数器记录的才是下一条指令的地址。**

### 1、3线程创建与运行

#### 1.3.1 创建线程

- 实现Runnable接口

  ```java
  public class MyRunnable implements Runnable{
      @Override
      public void run() {
          System.out.println("线程");
      }
  
      public static void main(String[] args) {
          MyRunnable instance = new MyRunnable();
          Thread thread = new Thread(instance);
          thread.start();
      }
  }
  ```

- 实现Callable接口（带有返回值）

  ```java
  public class MyCallable implements Callable<Integer> {
      @Override
      public Integer call() throws Exception {
          Thread.sleep(10000);
          return 1;
      }
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          MyCallable callable = new MyCallable();
          FutureTask<Integer> futureTask = new FutureTask<>(callable);
          Thread thread = new Thread(futureTask);
          thread.start();
          System.out.println(futureTask.get());
      }
  }
  ```

- 继承Thread类

  ```java
  public class MyThread extends Thread{
      @Override
      public void run() {
          System.out.println(Thread.currentThread().getName());
      }
  
      public static void main(String[] args) {
          MyThread thread = new MyThread();
          thread.start();
      }
  }
  ```

**实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。**

#### 1.3.2 线程通知与等待

- wait方法

​	当线程调用了该方法时，该线程会被挂起，知道发生下面几件事情之一才会返回：

```reStructuredText
（1）其他线程调用了该共享对象的notify()或者notifyAll()方法；
（2）其他线程调用了该线程的interrupt()方法，该线程会抛出异常返回
```

- notify方法和notifyAll方法

  一个线程调用共享对象的notify方法后，会唤醒一个在该共享变量上调用wait系列方法后被挂起的线程，**具体唤醒哪个线程是随机的**。notifyAll则是唤醒全部。

#### 1.3.3 等待线程执行终止的join方法

> 在线程中调用另一个线程的 join() 方法，**会将当前线程挂起**（无关的线程不会挂起），而不是忙等待，直到目标线程结束。

```java
public class JoinDemo {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (;;){

                }
            }
        });
        Thread mainThread = Thread.currentThread();
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //调用主线程中断
                mainThread.interrupt();
            }
        });
        //启动线程1
        thread1.start();
		//启动线程2
        thread2.start();

        try {
            //等待线程1执行完，但同时线程2触发了主线程中断，
            thread1.join();
        } catch (InterruptedException e) {
            //获取主线程异常信息
            System.out.println(e);
        }
    }
}
```

#### 1.3.4 线程的sleep方法	

​	当一个执行中的线程调用了Thread的sleep方法后，调用线程会短暂让出**指定时间的执行权**，在这段期间不参合与CPU的调度。**但是该线程所拥有的监视器资源比如锁还是持有不让出的。**不过对于调用了线程的中断方法后，还是会结束该线程的。

```java
public class SleepDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                System.out.println("子线程正在睡眠");
                Thread.sleep(10000);
                System.out.println("子线程已经被唤醒");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        });
        thread.start();

        //主线程休眠2s
        Thread.sleep(2000);

        //中断子线程
        thread.interrupt();
    }
}
```

#### 1.3.5 让出CPU执行权的yield方法

​	当一个线程调用yield方法时，可以切换给其它线程来执行。此时该该线程处于就绪状态；线程下一次调度时就有可能调度到当前线程执行。



## Future模式

> Future模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。

### 普通模式与`Future`模式对比

![img](https://upload-images.jianshu.io/upload_images/6546990-c945e25d3f141b77.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/703/format/webp)

### `Quick Start`

```java
class FutureBootstrap1{
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        Thread thread = new Thread(new RunnableDemo());
        Future<?> data = cachedThreadPool.submit(thread);
        //使用data.get()数据会使主线程阻塞；输出结果是：子进程->主进程
        //隐藏该行输出结果是：主进程->子进程
        Object o = data.get();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程");
    }
    public static class RunnableDemo implements Runnable{

        @Override
        public void run() {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子进程");
        }
    }
}
```

**参考地址：[Future模式](https://www.jianshu.com/p/fae49ce237b3)**

