# 并发编程

## 1、并发编程基础

### 1、1 线程与进程

**进程**

> ​	我们都知道计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是**操作系统进行资源分配和调度**的一个独立单位，是应用程序运行的载体。

**线程**

> ​	线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。**一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。真正占用CPU运行的是线程，所以也说线程是CPU分配的基本单位。**

**线程与进程的区别**

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；

4. 调度和切换：线程上下文切换比进程上下文切换要快得多

![进程与线程](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201118232218.png)

​																						**进程与线程**

### 1、2 并发

> ​	**大部分操作系统的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态，等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。**
>
> ​	**那么在时间片被其他线程占用后，如何知道之前的线程执行到哪里了？程序计数器（pc计数器）就是为了记录该线程让出CPU时的执行地址的。待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行。另外需要注意的是：如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是java代码时pc计数器记录的才是下一条指令的地址。**

### 1、3线程创建与运行

#### 1.3.1 创建线程

- 实现Runnable接口

  ```java
  public class MyRunnable implements Runnable{
      @Override
      public void run() {
          System.out.println("线程");
      }
  
      public static void main(String[] args) {
          MyRunnable instance = new MyRunnable();
          Thread thread = new Thread(instance);
          thread.start();
      }
  }
  ```

- 实现Callable接口（带有返回值）

  ```java
  public class MyCallable implements Callable<Integer> {
      @Override
      public Integer call() throws Exception {
          Thread.sleep(10000);
          return 1;
      }
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          MyCallable callable = new MyCallable();
          FutureTask<Integer> futureTask = new FutureTask<>(callable);
          Thread thread = new Thread(futureTask);
          thread.start();
          System.out.println(futureTask.get());
      }
  }
  ```

- 继承Thread类

  ```java
  public class MyThread extends Thread{
      @Override
      public void run() {
          System.out.println(Thread.currentThread().getName());
      }
  
      public static void main(String[] args) {
          MyThread thread = new MyThread();
          thread.start();
      }
  }
  ```

**实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。**

#### 1.3.2 线程通知与等待

- wait方法

​	当线程调用了该方法时，该线程会被挂起，知道发生下面几件事情之一才会返回：

```reStructuredText
（1）其他线程调用了该共享对象的notify()或者notifyAll()方法；
（2）其他线程调用了该线程的interrupt()方法，该线程会抛出异常返回
```

- notify方法和notifyAll方法

  一个线程调用共享对象的notify方法后，会唤醒一个在该共享变量上调用wait系列方法后被挂起的线程，**具体唤醒哪个线程是随机的**。notifyAll则是唤醒全部。

#### 1.3.3 等待线程执行终止的join方法

> 在线程中调用另一个线程的 join() 方法，**会将当前线程挂起**（无关的线程不会挂起），而不是忙等待，直到目标线程结束。

```java
public class JoinDemo {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (;;){

                }
            }
        });
        Thread mainThread = Thread.currentThread();
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //调用主线程中断
                mainThread.interrupt();
            }
        });
        //启动线程1
        thread1.start();
		//启动线程2
        thread2.start();

        try {
            //等待线程1执行完，但同时线程2触发了主线程中断，
            thread1.join();
        } catch (InterruptedException e) {
            //获取主线程异常信息
            System.out.println(e);
        }
    }
}
```

#### 1.3.4 线程的sleep方法	

​	当一个执行中的线程调用了Thread的sleep方法后，调用线程会短暂让出**指定时间的执行权**，在这段期间不参合与CPU的调度。**但是该线程所拥有的监视器资源比如锁还是持有不让出的。**不过对于调用了线程的中断方法后，还是会结束该线程的。

```java
public class SleepDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                System.out.println("子线程正在睡眠");
                Thread.sleep(10000);
                System.out.println("子线程已经被唤醒");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        });
        thread.start();

        //主线程休眠2s
        Thread.sleep(2000);

        //中断子线程
        thread.interrupt();
    }
}
```

#### 1.3.5 让出CPU执行权的yield方法

​	当一个线程调用yield方法时，可以切换给其它线程来执行。此时该该线程处于就绪状态；线程下一次调度时就有可能调度到当前线程执行。

#### 1.3.6 线程中断

​	Java中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。

- interrupt()方法

  ```java
  public static void main(String[] args) {
      Thread threadA = new Thread(new Runnable() {
          @Override
          public void run() {
              try {
                  Thread.sleep(10000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      });
      Thread threadB = new Thread(new Runnable() {
          @Override
          public void run() {
              //仅仅是设置中断标志，线程A实际并没有被中断。但是当线程A调用了wait\join\sleep方法而阻塞被挂起，这时候会抛出InterruptedException异常
              threadA.interrupt();
          }
      });
      threadA.start();
      threadB.start();
  
  }
  ```

- isInterrupted()方法

  检测当前线程是否被中断，如果是则返回true,否则返回false。

  ```java
  public static void main(String[] args) {
      Thread threadA = new Thread(new Runnable() {
          @Override
          public void run() {
              while (!Thread.interrupted()){
  
              }
              System.out.println("Thread end");
          }
      });
  	//false
      System.out.println("启动前："+threadA.isInterrupted());
      threadA.start();
      //false
      System.out.println("启动后："+threadA.isInterrupted());
      threadA.interrupt();
      //true
      System.out.println("中断后："+threadA.isInterrupted());
  }
  ```

- interrupted()

  ```java
  public static void main(String[] args) throws InterruptedException {
      Thread threadA = new Thread(new Runnable() {
          @Override
          public void run() {
              while (!Thread.interrupted()){
  
              }
              //复位 false
              System.out.println("threadOne isInterrupted:"+Thread.currentThread().isInterrupted());
          }
      });
  
      threadA.start();
  
      //获取中断标志 false
      System.out.println("isInterrupted:"+threadA.isInterrupted());
      //设置中断标志位为true
      threadA.interrupt();
  
      Thread.sleep(2000);
      //获取中断标志 false
      System.out.println("isInterrupted:"+threadA.isInterrupted());
  
      threadA.join();
  
      System.out.println("main thread is over");
  
  }
  ```


#### 1.3.7 守护线程与用户线程

​	Java中的线程分为**守护线程**和**用户线程**。在JVM启动时会调用main函数，main函数所在的线程就是用户线程；同时在jvm内部还启动了很多守护线程，比如垃圾回收线程。

```java
public static void main(String[] args) {
    Thread thread =new Thread(new Runnable() {
        @Override
        public void run() {
            while (true){

            }
        }
    });
    //当设置为true时，主线程结束jvm也就结束进程；当false时，主线程结束，jvm依然在运行。
    thread.setDaemon(true);
    thread.start();
}
```

```java
//tomcat内部源码 基于tomcat9版本
public void startInternal() throws Exception {

    if (!running) {
        running = true;
        paused = false;

        if (socketProperties.getProcessorCache() != 0) {
            processorCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,
                                                     socketProperties.getProcessorCache());
        }
        if (socketProperties.getEventCache() != 0) {
            eventCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,
                                                 socketProperties.getEventCache());
        }
        if (socketProperties.getBufferPool() != 0) {
            nioChannels = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,
                                                  socketProperties.getBufferPool());
        }

        // Create worker collection
        if (getExecutor() == null) {
            createExecutor();
        }

        initializeConnectionLatch();

        // Start poller thread
        poller = new Poller();
        Thread pollerThread = new Thread(poller, getName() + "-ClientPoller");
        pollerThread.setPriority(threadPriority);
        //设置为守护线程
        pollerThread.setDaemon(true);
        pollerThread.start();

        startAcceptorThread();
    }
}
protected void startAcceptorThread() {
    acceptor = new Acceptor<>(this);
    String threadName = getName() + "-Acceptor";
    acceptor.setThreadName(threadName);
    Thread t = new Thread(acceptor, threadName);
    t.setPriority(getAcceptorThreadPriority());
    //设置为守护线程
    t.setDaemon(getDaemon());
    t.start();
}
```

#### 1.3.8 ThreadLocal

​	如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本；当多线程操作这个变量时，实际操作的是自己本地内存的变量，从而避免了线程安全问题。

##### **示例**

```java
public static void main(String[] args) {
    ThreadLocal threadLocal1 = new ThreadLocal();
    ThreadLocal threadLocal2 = new ThreadLocal();
    Thread thread1 = new Thread(() -> {
        threadLocal1.set(1);
        threadLocal2.set(1);
    });
    Thread thread2 = new Thread(() -> {
        threadLocal1.set(2);
        threadLocal2.set(2);
    });
    thread1.start();
    thread2.start();
}
```

**上述代码内部结构如下**

![ThreadLocal](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201126225443.png)

##### ThreadLocal的实现原理

`java.lang.ThreadLocal#set`

```java
public void set(T value) {
    //获取当前线程
    Thread t = Thread.currentThread();
    //从线程中获取ThreadLocalMap对象，ThreadLocalMap定制化的hashMap；存储ThreadLocal-value键值对
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        //第一次创建map
        createMap(t, value);
}

void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
ThreadLocalMap getMap(Thread t) {
    //获取Thread类中的ThreadLocal.ThreadLocalMap threadLocals = null;
    return t.threadLocals;
}

```

`java.lang.ThreadLocal#get`

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        //通过hash计算获取对应的Entry=table[i]
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    //theradLocals为空则初始化当前threadLocals成员变量
    return setInitialValue();
}
private T setInitialValue() {
    //初始化为null
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    //如果当前线程的threadLocals变量不为空，则设置当前线程的本地变量值为null
    if (map != null)
        map.set(this, value);
   	//否则调用createMap方法创建当前线程的createMap变量。
    else
        createMap(t, value);
    return value;
}
protected T initialValue() {
    return null;
}
```

`java.lang.ThreadLocal#remove`

```java
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}
```

##### 内存泄漏

`ThreadLocalMap 构造`	

```java
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY];
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    table[i] = new Entry(firstKey, firstValue);
    size = 1;
    setThreshold(INITIAL_CAPACITY);
}
```

`Entry类`

```java
//该类使用类弱引用WeakReference
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```

> 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

​	`在每个线程内部都有一个名为threadLocals的成员变量，该变量为定制化的HashMap，键值对key为当前ThreadLocal变量，value为设置的值。每个线程的本地变量都会存放在自己的内存变量threadLocals中，如果ThreadLocal没有被ThreadLocalMap以外的对象引用，在下一次GC的时候，ThreadLocal实例就会被回收，那么ThreadLocalMap中ThreadLocal所表示的key就是null了，那么value便不会被外部访问到；只要Thread实例一直存在，这里key为null的value就一直占用着内存。为了避免内存溢出，则需要手动调用remove()方法。`

[ThreadLocal原理及内存泄露的解决](https://blog.csdn.net/happygan520/article/details/104680694)

## Future模式

> Future模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。

### 普通模式与`Future`模式对比

![img](https://upload-images.jianshu.io/upload_images/6546990-c945e25d3f141b77.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/703/format/webp)

### `Quick Start`

```java
class FutureBootstrap1{
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        Thread thread = new Thread(new RunnableDemo());
        Future<?> data = cachedThreadPool.submit(thread);
        //使用data.get()数据会使主线程阻塞；输出结果是：子进程->主进程
        //隐藏该行输出结果是：主进程->子进程
        Object o = data.get();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程");
    }
    public static class RunnableDemo implements Runnable{

        @Override
        public void run() {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子进程");
        }
    }
}
```

**参考地址：[Future模式](https://www.jianshu.com/p/fae49ce237b3)**

