# 并发编程

## 1、并发编程基础

### 1、1 线程与进程

**进程**

> ​	我们都知道计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是**操作系统进行资源分配和调度**的一个独立单位，是应用程序运行的载体。

**线程**

> ​	线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。**一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。真正占用CPU运行的是线程，所以也说线程是CPU分配的基本单位。**

**线程与进程的区别**

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；

4. 调度和切换：线程上下文切换比进程上下文切换要快得多

![进程与线程](https://image-1301573777.cos.ap-chengdu.myqcloud.com/20201118232218.png)

​																						**进程与线程**

### 1、2 并发

> ​	**大部分操作系统的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态，等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。**
>
> ​	**那么在时间片被其他线程占用后，如何知道之前的线程执行到哪里了？程序计数器（pc计数器）就是为了记录该线程让出CPU时的执行地址的。待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行。另外需要注意的是：如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是java代码时pc计数器记录的才是下一条指令的地址。**



## Future模式

> Future模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。

### 普通模式与`Future`模式对比

![img](https://upload-images.jianshu.io/upload_images/6546990-c945e25d3f141b77.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/703/format/webp)

### `Quick Start`

```java
class FutureBootstrap1{
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        Thread thread = new Thread(new RunnableDemo());
        Future<?> data = cachedThreadPool.submit(thread);
        //使用data.get()数据会使主线程阻塞；输出结果是：子进程->主进程
        //隐藏该行输出结果是：主进程->子进程
        Object o = data.get();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程");
    }
    public static class RunnableDemo implements Runnable{

        @Override
        public void run() {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子进程");
        }
    }
}
```

**参考地址：[Future模式](https://www.jianshu.com/p/fae49ce237b3)**

